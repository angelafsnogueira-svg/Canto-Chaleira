<!DOCTYPE html>
<html lang="pt-PT">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>O Canto da Chaleira</title>
  
  <!-- CSS -->
  <link rel="stylesheet" href="../css/style.css">

  <!-- Font Awesome -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css">

  <!-- Google Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Macondo&family=Qwitcher+Grypen:wght@400;700&family=Lexend:wght@100..900&family=Lilita+One&display=swap" rel="stylesheet">
  <style>
  body {
    background: rgba(17, 17, 17, 0.02);
    background-image: url("../imagens/Diversos/clean-gray-paper.png");
  }
  </style>
</head>

<body>

  <!-- Cabeçalho superior -->
  <div class="topbar">
    <a href="https://discord.gg/SEU-LINK" target="_blank" title="Discord">
      <i class="fa-brands fa-discord"></i>
    </a>
  </div>

  <header class="site-header">
    <div class="topbar">
      <a href="https://discord.gg/SEU-LINK" target="_blank" title="Discord">
        <i class="fa-brands fa-discord"></i>
      </a>
    </div>

    <div class="overlay"></div>
    <div class="content">
      <img src="../imagens/Diversos/CCLogo.png" alt="Logotipo" class="logo">
      <h1>O Canto da Chaleira</h1>
      <p class="slogan">Promovendo a criatividade. Enriquecendo a comunidade.</p>
    </div>

    <nav class="menu">
      <a href="../index.html">Início</a>
      <a href="../sobre.html">Sobre Nós</a>
      <a href="../artistas.html" class="active">Artistas</a>
      <a href="../atividades.html">Atividades</a>
      <a href="../eventos.html">Eventos</a>
      <a href="../parcerias.html">Parcerias</a>
      <a href="../contacto.html">Contacto</a>
    </nav>
  </header>

  <script>
    window.addEventListener('scroll', function() {
      const menu = document.querySelector('.menu');
      if(window.scrollY > 50){
        menu.classList.add('scrolled');
      } else {
        menu.classList.remove('scrolled');
      }
    });
  </script>

  <!-- CONTAINER: Menu lateral + Conteúdo -->
  <div class="artist-container">

    <!-- Menu lateral -->
    <aside class="side-menu">
      <nav>
        <a href="#artist-intro"><i class="fa-solid fa-user"></i> Introdução</a>
        <a href="#gallery"><i class="fa-solid fa-image"></i> Galeria</a>
        <a href="#playlist"><i class="fa-solid fa-music"></i> Singles</a>
        <a href="#calendar"><i class="fa-solid fa-calendar"></i> Agenda</a>
        <a href="#links"><i class="fa-solid fa-link"></i> Links</a>
      </nav>
    </aside>

    <!-- Conteúdo principal -->
    <main class="artist-profile">
      <!-- Intro -->
      <section class="artist-intro" id="artist-intro">
        <h2>Cristóvão McDuffin</h2>
        <img src="../imagens/People/Cristovao/cristovao3.png" alt="Foto do Artista" class="artist-photo">
        <p><strong>Cristóvão McDuffin</strong> é um cantor português residente em Puerto Esperanza. O seu percurso artístico iniciou-se aos 21 anos, quando se mudou para a cidade 
          para prosseguir os seus estudos, momento em que começou a dedicar-se à música de forma mais consistente.</p>
        <br>
        <p>Ao longo do seu trajeto, Cristóvão atuou em diversos espaços culturais e de entretenimento da cidade, entre os quais o restaurante <strong>Hog's</strong>, o bar noturno 
          <strong>Malibu</strong>, o restaurante <strong>BurgerShot</strong> e a empresa de gravação <strong>Rockford Records</strong>, onde chegou a ser proprietário e onde também 
          se apresentou em palco. Para além disso, participou num programa de talentos, no qual alcançou a final e apresentou a sua primeira música original, <strong>“Pergaminho”</strong>
           e esteve presente como cantor num reality show.</p>
        <br>
        <p>O seu estilo musical caracteriza-se pela versatilidade, com particular incidência na Música Portuguesa, pop e rock. Habitualmente apresenta-se acompanhado da sua guitarra 
          acústica, elemento central na sua expressão artística.</p>
        <br>
        <p>Cristóvão McDuffin tem ainda desenvolvido colaborações com outros músicos, destacando-se a canção <strong>“Estica-me as Peles”</strong>, gravada em parceria com o artista
           <strong>John Blake</strong>. Apesar de ainda não ter recebido distinções formais, tem vindo a afirmar-se no panorama artístico local, consolidando gradualmente a sua 
           presença na cena musical de Puerto Esperanza.</p>
      </section>

      <!-- Gallery -->
      <section class="artist-gallery" id="gallery">
        <h2>Galeria</h2>
        <div class="galeria-artista">
          <button class="galeria-btn prev">‹</button>
            <div class="galeria-track-container">
              <div class="galeria-track">
                <img src="../imagens/People/Cristovao/cristovão2.png" alt="Foto 1" class="galeria-img">
                <img src="../imagens/People/Cristovao/cristovao5.png" alt="Foto 2" class="galeria-img">
                <img src="../imagens/People/Cristovao/cristovao1.png" alt="Foto 3" class="galeria-img">
                <img src="../imagens/People/Cristovao/cm3.png" alt="Foto 4" class="galeria-img">
                <img src="../imagens/People/Cristovao/cm2.png" alt="Foto 5" class="galeria-img">
                <img src="../imagens/People/Cristovao/cristovao4.png" alt="Foto 6" class="galeria-img">
                <img src="../imagens/People/Cristovao/cristovao6.png" alt="Foto 7" class="galeria-img">
              </div>
            </div>
          <button class="galeria-btn next">›</button>
        </div>
      </section>


      <script>
        document.addEventListener("DOMContentLoaded", function () {
          const track = document.querySelector(".galeria-track");
          const prevBtn = document.querySelector(".galeria-btn.prev");
          const nextBtn = document.querySelector(".galeria-btn.next");
          const imgs = document.querySelectorAll(".galeria-img");

          let currentIndex = 0;
          const imgWidth = imgs[0].offsetWidth; // largura de cada foto

          function updateGaleria() {
          track.style.transform = `translateX(${-currentIndex * imgWidth}px)`;
          }

          nextBtn.addEventListener("click", () => {
            if (currentIndex < imgs.length - 1) {
            currentIndex++;
            updateGaleria();
            }
          });

          prevBtn.addEventListener("click", () => {
            if (currentIndex > 0) {
            currentIndex--;
            updateGaleria();
            }
          });

          // Esconde botões se só existir 1 imagem
          if (imgs.length <= 1) {
            prevBtn.style.display = "none";
            nextBtn.style.display = "none";
          }
        });
      </script>

<!-- PLAYLIST (substituir o bloco antigo por este) -->
<section class="artist-playlist" id="playlist">
  <h2>Singles</h2>

  <div class="track" data-video="FbgPrumHJM4">
    <div class="track-header" tabindex="0">"Pergaminho" (Incompleto)</div>
    <div class="track-content">
      <div class="controls" role="group" aria-label="Controlo da faixa">
        <button class="play-btn" title="Play/Pause" aria-label="Play/Pause"><i class="fa-solid fa-play"></i></button>
        <button class="loop-btn" title="Repetir" aria-pressed="false" aria-label="Repetir"><i class="fa-solid fa-repeat"></i></button>
      </div>

      <div class="waveform" aria-hidden="true"></div>

      <div class="progress-container" aria-label="Barra de progresso" role="slider" tabindex="0">
        <div class="progress"></div>
        <div class="progress-handle" aria-hidden="true"></div>
      </div>

      <div class="time-vol">
        <span class="time">0:00 / 0:00</span>
        <input type="range" class="volume" min="0" max="100" value="100" aria-label="Volume">
      </div>
    </div>
  </div>

  <div class="track" data-video="jwUSsWgay3g">
    <div class="track-header" tabindex="0">"Estica-me as Peles" John Blake feat. McDuffin</div>
    <div class="track-content">
      <div class="controls" role="group" aria-label="Controlo da faixa">
        <button class="play-btn" title="Play/Pause" aria-label="Play/Pause"><i class="fa-solid fa-play"></i></button>
        <button class="loop-btn" title="Repetir" aria-pressed="false" aria-label="Repetir"><i class="fa-solid fa-repeat"></i></button>
      </div>

      <div class="waveform" aria-hidden="true"></div>

      <div class="progress-container" aria-label="Barra de progresso" role="slider" tabindex="0">
        <div class="progress"></div>
        <div class="progress-handle" aria-hidden="true"></div>
      </div>

      <div class="time-vol">
        <span class="time">0:00 / 0:00</span>
        <input type="range" class="volume" min="0" max="100" value="100" aria-label="Volume">
      </div>
    </div>
  </div>

  <div class="track" data-video="w8vTw8ZTur8">
    <div class="track-header" tabindex="0">"Those Eyes" New West Cover</div>
    <div class="track-content">
      <div class="controls" role="group" aria-label="Controlo da faixa">
        <button class="play-btn" title="Play/Pause" aria-label="Play/Pause"><i class="fa-solid fa-play"></i></button>
        <button class="loop-btn" title="Repetir" aria-pressed="false" aria-label="Repetir"><i class="fa-solid fa-repeat"></i></button>
      </div>

      <div class="waveform" aria-hidden="true"></div>

      <div class="progress-container" aria-label="Barra de progresso" role="slider" tabindex="0">
        <div class="progress"></div>
        <div class="progress-handle" aria-hidden="true"></div>
      </div>

      <div class="time-vol">
        <span class="time">0:00 / 0:00</span>
        <input type="range" class="volume" min="0" max="100" value="100" aria-label="Volume">
      </div>
    </div>
  </div>

  <!-- Hidden YouTube players -->
  <div id="players-container" style="display:none;"></div>
</section>

<!-- CSS (integra no teu style.css) -->
<style>
/* --- playlist base --- */
.artist-playlist{margin:40px auto;max-width:900px;font-family:"Lexend",sans-serif}
.artist-playlist h2{text-align:center;margin-bottom:20px;font-size:26px}

/* track card */
.track{background:#fff;border-radius:10px;box-shadow:0 4px 16px rgba(0,0,0,0.06);margin-bottom:16px;overflow:hidden;transition:box-shadow .2s,border-color .2s}
.track.playing{border:2px solid #4f46e5;box-shadow:0 8px 30px rgba(79,70,229,0.14)}
.track-header{padding:12px 16px;background:#f3f4f6;cursor:pointer;font-weight:600;outline:none}
.track-content{max-height:0;overflow:hidden;transition:max-height .45s ease,padding .2s; padding:0 16px}
.track.active .track-content{max-height:260px;padding:16px}

/* controls */
.controls{display:flex;gap:8px;margin-bottom:12px}
.controls button{border:0;background:#e6e7ee;color:#111;padding:10px;border-radius:8px;cursor:pointer;font-size:16px;transition:background .15s}
.controls button:hover{background:#d6d7e6}
.controls button.active{background:#4f46e5;color:#fff}

/* waveform decorative */
.waveform{display:flex;gap:2px;height:60px;align-items:flex-end;margin-bottom:10px}
.waveform .bar{width:3px;background:#a3a3a3;border-radius:2px;height:10px;transition:height .18s linear}

/* progress */
.progress-container{width:100%;height:8px;background:#e5e7eb;border-radius:999px;margin:8px 0;position:relative;cursor:pointer;user-select:none}
.progress{position:absolute;left:0;top:0;height:100%;background:#111827;width:0;border-radius:999px;transition:width .1s linear}
.progress-handle{position:absolute;top:50%;transform:translate(-50%,-50%);width:12px;height:12px;border-radius:50%;background:#fff;border:2px solid #111827;box-shadow:0 2px 6px rgba(0,0,0,.12);left:0;pointer-events:none;transition:left .05s linear}

/* time + volume */
.time-vol{display:flex;justify-content:space-between;align-items:center;gap:12px}
.time{font-size:14px;color:#444;min-width:110px}
.volume{flex:1;margin-left:12px}

/* small screens */
@media (max-width:720px){
  .track.active .track-content{max-height:340px}
  .waveform{height:48px}
  .time{min-width:70px}
}
</style>

<!-- SCRIPT (cola no fim do body ou imediatamente após o bloco acima) -->
<script>
/*
  Player robusto:
  - usa API do YouTube com onReady / onStateChange
  - progress bar clicável + arrastável (pointer events)
  - volume persistente (localStorage)
  - waveform decorativa e animada quando a faixa toca
  - evita chamadas inseguras antes do player estar pronto
*/
(function(){
  const trackEls = Array.from(document.querySelectorAll('.track'));
  if(trackEls.length===0) return;

  const players = [];            // YT.Player instances
  const state = [];              // per-track state {ready, looping, dragging}
  const barsMap = [];            // waveform bars
  const barsCount = 36;

  // helper
  function fmt(sec){
    sec = Math.max(0, Math.floor(sec||0));
    const m = Math.floor(sec/60);
    const s = sec%60;
    return m + ':' + (s<10?'0'+s:s);
  }

  function createWaveform(track, idx){
    const wf = track.querySelector('.waveform');
    wf.innerHTML = '';
    const bars = [];
    for(let i=0;i<barsCount;i++){
      const b = document.createElement('div');
      b.className = 'bar';
      wf.appendChild(b);
      bars.push(b);
    }
    barsMap[idx] = bars;
  }

  // init UI for each track
  trackEls.forEach((track, idx)=>{
    state[idx] = {ready:false,looping:false,dragging:false,mouseDown:false};
    createWaveform(track, idx);

    // toggle expand on header (keyboard accessible)
    const header = track.querySelector('.track-header');
    header.addEventListener('click', ()=> track.classList.toggle('active'));
    header.addEventListener('keydown', (ev)=>{ if(ev.key==='Enter' || ev.key===' ') { ev.preventDefault(); track.classList.toggle('active'); } });

    // play / loop / volume UI handlers will be bound after player ready
  });

  // ---- YouTube API loader & init ----
  function loadYouTubeAPI(cb){
    if(window.YT && window.YT.Player){ cb(); return; }
    // attach global callback
    const prev = window.onYouTubeIframeAPIReady;
    window.onYouTubeIframeAPIReady = function(){
      if(typeof prev === 'function') prev();
      cb();
    };
    // inject script only if not already present
    if(!document.querySelector('script[src*="youtube.com/iframe_api"]')){
      const tag = document.createElement('script');
      tag.src = "https://www.youtube.com/iframe_api";
      tag.async = true;
      document.head.appendChild(tag);
    }
  }

  function initPlayers(){
    const container = document.getElementById('players-container') || (function(){ const d=document.createElement('div'); d.id='players-container'; d.style.display='none'; document.body.appendChild(d); return d; })();

    trackEls.forEach((track, idx)=>{
      const videoId = track.dataset.video;
      const playerDiv = document.createElement('div');
      playerDiv.id = 'yt-player-' + idx;
      container.appendChild(playerDiv);

      players[idx] = new YT.Player(playerDiv.id, {
        videoId,
        playerVars: { autoplay:0, controls:0, modestbranding:1, rel:0 },
        events: {
          onReady: (ev)=> onPlayerReady(ev, idx),
          onStateChange: (ev)=> onPlayerStateChange(ev, idx)
        }
      });

      // bind UI handlers now (they reference players[idx] but guard when not ready)
      bindUI(track, idx);
    });

    // start animation loop
    requestAnimationFrame(loopTick);
  }

  // Called when a player signals ready
  function onPlayerReady(ev, idx){
    state[idx].ready = true;
    // restore volume
    const vol = localStorage.getItem('ocv-vol-'+idx);
    if(vol !== null){
      try{ players[idx].setVolume(Number(vol)); }catch(e){}
      const volInput = trackEls[idx].querySelector('.volume');
      if(volInput) volInput.value = vol;
    } else {
      try{ players[idx].setVolume(100); }catch(e){}
    }
  }

  // handle play/pause visual when state changes
  function onPlayerStateChange(ev, idx){
    const track = trackEls[idx];
    const playBtnIcon = track.querySelector('.play-btn i');
    const isPlaying = (ev.data === YT.PlayerState.PLAYING);
    const isPaused  = (ev.data === YT.PlayerState.PAUSED);
    const isEnded   = (ev.data === YT.PlayerState.ENDED);

    if(isPlaying){
      track.classList.add('playing');
      if(playBtnIcon) playBtnIcon.className = 'fa-solid fa-pause';
    } else {
      track.classList.remove('playing');
      if(playBtnIcon) playBtnIcon.className = 'fa-solid fa-play';
    }

    if(isEnded){
      if(state[idx].looping && players[idx] && typeof players[idx].seekTo === 'function'){
        players[idx].seekTo(0);
        players[idx].playVideo();
      } else {
        // set icon to play
        if(playBtnIcon) playBtnIcon.className = 'fa-solid fa-play';
        track.classList.remove('playing');
      }
    }
  }

  // UI binding (safe even before player ready)
  function bindUI(track, idx){
    const playBtn = track.querySelector('.play-btn');
    const loopBtn = track.querySelector('.loop-btn');
    const volInput = track.querySelector('.volume');
    const timeEl  = track.querySelector('.time');
    const progressContainer = track.querySelector('.progress-container');
    const progressEl = track.querySelector('.progress');
    const handle = track.querySelector('.progress-handle');

    // Play / Pause
    playBtn.addEventListener('click', ()=>{
      // pause others
      players.forEach((p,i)=>{ if(i!==idx && p && typeof p.pauseVideo==='function') try{ p.pauseVideo(); }catch(e){} });
      // toggle this
      const p = players[idx];
      if(!p) return;
      const stateCode = (typeof p.getPlayerState === 'function') ? p.getPlayerState() : -1;
      if(stateCode === YT.PlayerState.PLAYING){
        try{ p.pauseVideo(); }catch(e){}
      } else {
        try{ p.unMute(); p.playVideo(); }catch(e){}
      }
    });

    // Loop
    loopBtn.addEventListener('click', ()=>{
      state[idx].looping = !state[idx].looping;
      loopBtn.classList.toggle('active', state[idx].looping);
      loopBtn.setAttribute('aria-pressed', state[idx].looping ? 'true' : 'false');
    });

    // Volume persistence
    volInput.addEventListener('input', ()=>{
      const v = volInput.value;
      localStorage.setItem('ocv-vol-'+idx, v);
      const p = players[idx];
      if(p && typeof p.setVolume === 'function'){
        try{ p.setVolume(Number(v)); }catch(e){}
      }
    });

    // Progress click + drag (pointer events)
    let pointerDown = false;
    function pctFromEvent(evt){
      const rect = progressContainer.getBoundingClientRect();
      const clientX = (evt.touches ? evt.touches[0].clientX : evt.clientX);
      let x = clientX - rect.left;
      x = Math.max(0, Math.min(rect.width, x));
      return x / rect.width;
    }

    function seekToPct(pct){
      const p = players[idx];
      if(!p || typeof p.getDuration !== 'function') return;
      const dur = p.getDuration();
      if(!isFinite(dur) || dur <= 0) return;
      const target = dur * pct;
      try{ p.seekTo(target, true); }catch(e){}
    }

    // pointerdown
    progressContainer.addEventListener('pointerdown', (ev)=>{
      ev.preventDefault();
      pointerDown = true;
      state[idx].dragging = true;
      const pct = pctFromEvent(ev);
      // update UI immediately
      progressEl.style.width = (pct*100)+'%';
      handle.style.left = (pct*100)+'%';
      // keep moving
      progressContainer.setPointerCapture(ev.pointerId);
    });

    // pointermove
    progressContainer.addEventListener('pointermove', (ev)=>{
      if(!pointerDown) return;
      const pct = pctFromEvent(ev);
      progressEl.style.width = (pct*100)+'%';
      handle.style.left = (pct*100)+'%';
    });

    // pointerup -> seek
    progressContainer.addEventListener('pointerup', (ev)=>{
      if(!pointerDown) return;
      pointerDown = false;
      state[idx].dragging = false;
      const pct = pctFromEvent(ev);
      progressEl.style.width = (pct*100)+'%';
      handle.style.left = (pct*100)+'%';
      seekToPct(pct);
      try{ progressContainer.releasePointerCapture(ev.pointerId); }catch(e){}
    });

    // also allow keyboard seeking (arrow left/right, home/end)
    progressContainer.addEventListener('keydown', (ev)=>{
      const p = players[idx];
      if(!p || typeof p.getDuration !== 'function') return;
      const dur = p.getDuration();
      if(!isFinite(dur) || dur <= 0) return;
      let pct = (p.getCurrentTime()||0) / dur;
      if(ev.key === 'ArrowRight') pct = Math.min(1, pct + 0.02);
      else if(ev.key === 'ArrowLeft') pct = Math.max(0, pct - 0.02);
      else if(ev.key === 'Home') pct = 0;
      else if(ev.key === 'End') pct = 1;
      else return;
      ev.preventDefault();
      seekToPct(pct);
    });

    // store references on element for animation loop
    track._ui = {progressEl, handle, timeEl, bars: barsMap[idx]};
  }

  // loopTick: updates waveform and time/progress periodically
  function loopTick(){
    trackEls.forEach((track, idx)=>{
      const p = players[idx];
      const st = state[idx];
      const ui = track._ui;
      if(!ui) return;

      // safe guards
      if(p && st && st.ready && typeof p.getDuration === 'function' && !st.dragging){
        const dur = p.getDuration();
        const cur = (typeof p.getCurrentTime === 'function') ? p.getCurrentTime() : 0;
        if(isFinite(dur) && dur > 0){
          ui.timeEl.textContent = fmt(cur) + ' / ' + fmt(dur);
          const pct = (cur / dur) * 100;
          ui.progressEl.style.width = pct + '%';
          ui.handle.style.left = pct + '%';
        } else {
          ui.timeEl.textContent = '0:00 / 0:00';
        }
      }

      // animate waveform only when playing
      try{
        const stateCode = (p && typeof p.getPlayerState === 'function') ? p.getPlayerState() : -1;
        if(stateCode === YT.PlayerState.PLAYING){
          // random heights for visual effect
          ui.bars.forEach(b=>{
            b.style.height = (Math.random()*48 + 8) + 'px';
            b.style.background = '#4f46e5';
          });
        } else {
          ui.bars.forEach(b=>{
            b.style.height = '8px';
            b.style.background = '#a3a3a3';
          });
        }
      }catch(e){
        // ignore transient errors
      }
    });

    requestAnimationFrame(loopTick);
  }

  // Initialize (load API if needed)
  loadYouTubeAPI(initPlayers);

  // --- debug helpers (visible in console) ---
  window._ocv_debug = {
    players, state, trackEls
  };
})();
</script>


      <!-- Calendar -->
      <section class="artist-calendar" id="calendar">
        <h2>Próximos Concertos</h2>
        <ul>
          <li>12 Março 2026 - Lisboa, Portugal</li>
          <li>28 Março 2026 - Porto, Portugal</li>
          <li>15 Abril 2026 - Madrid, Espanha</li>
        </ul>
      </section>

      <!-- Links -->
      <section class="artist-links" id="links">
        <h2>Siga o Artista</h2>
        <a href="https://youtube.com/" target="_blank"><i class="fa-brands fa-youtube"></i> YouTube</a>
        <a href="https://instagram.com/" target="_blank"><i class="fa-brands fa-instagram"></i> Instagram</a>
        <a href="https://spotify.com/" target="_blank"><i class="fa-brands fa-spotify"></i> Spotify</a>
        <a href="https://artistwebsite.com" target="_blank"><i class="fa-solid fa-globe"></i> Website Oficial</a>
      </section>
    </main>

  </div> <!-- /.artist-container -->

  <div class="advert-bar">
  <div class="advert-track">
    <a href="https://catalogopdmpe.vercel.app" target="blank">
      <img src="../imagens/Parcerias/pdm.png" alt="Publicidade 1">
    </a>
    <img src="../imagens/Parcerias/tunetown.png" alt="Publicidade 2">
    <img src="../imagens/Parcerias/academia.png" alt="Publicidade 3">
    <img src="../imagens/Parcerias/asfalto.png" alt="Publicidade 4">
    <!-- Duplicar as imagens para criar o efeito de loop -->
      <a href="https://catalogopdmpe.vercel.app" target="blank">
      <img src="../imagens/Parcerias/pdm.png" alt="Publicidade 1">
    </a>
    <img src="../imagens/Parcerias/tunetown.png" alt="Publicidade 2">
    <img src="../imagens/Parcerias/academia.png" alt="Publicidade 3">
    <img src="../imagens/Parcerias/asfalto.png" alt="Publicidade 4">
  </div>
</div>
  <!-- Footer -->
  <footer>
    <p>&copy; 2026 O Canto da Chaleira. Todos os direitos reservados.</p>
  </footer>

  <script>
const sideMenu = document.querySelector('.side-menu');
const menuLinks = document.querySelectorAll('.side-menu nav a');

const minHeight = 400; // altura inicial do menu

// Calcula a altura máxima com base no conteúdo principal, sem ultrapassar o footer
const mainContent = document.querySelector('.artist-profile');
const maxHeight = mainContent.offsetTop + mainContent.offsetHeight - sideMenu.offsetTop - 20; // margem de 20px

// Cores inicial e final (gradiente dinâmico)
const startMenuColor = {r: 255, g: 255, b: 255, a: 0.02}; // #f5f5f5
const endMenuColor   = {r: 235, g: 168, b: 60, a: 1};  // #eba83c

// Gradiente do conteúdo (links)
const startLinkColor = {r: 0, g: 0, b: 0};    // texto inicial
const endLinkColor = {r: 0, g: 0, b: 0};   // texto final

window.addEventListener('scroll', () => {
  const scrollY = window.scrollY;

  // Faz o menu crescer proporcionalmente ao scroll da página
  let newHeight = minHeight + scrollY;
  if (newHeight > maxHeight) newHeight = maxHeight;
  sideMenu.style.height = newHeight + "px";

  // Calcula progresso para revelar links
  let progress = (newHeight - minHeight) / (maxHeight - minHeight);

  // Links animados
  menuLinks.forEach((link, index) => {
    const delay = index * 0;
    link.style.opacity = progress > delay ? 1 : 0;
    link.style.transform = progress > delay ? "translateY(0)" : "translateY(20px)";

    // Gradiente de cor do link
    const r = Math.round(startLinkColor.r + (endLinkColor.r - startLinkColor.r) * progress);
    const g = Math.round(startLinkColor.g + (endLinkColor.g - startLinkColor.g) * progress);
    const b = Math.round(startLinkColor.b + (endLinkColor.b - startLinkColor.b) * progress);
    link.style.color = `rgb(${r},${g},${b})`;
  });

  // Gradiente do fundo do menu
  const rMenu = Math.round(startMenuColor.r + (endMenuColor.r - startMenuColor.r) * progress);
  const gMenu = Math.round(startMenuColor.g + (endMenuColor.g - startMenuColor.g) * progress);
  const bMenu = Math.round(startMenuColor.b + (endMenuColor.b - startMenuColor.b) * progress);
  const aMenu = startMenuColor.a + (endMenuColor.a - startMenuColor.a) * progress; // <<< sem Math.round
  sideMenu.style.backgroundColor = `rgba(${rMenu},${gMenu},${bMenu},${aMenu})`;
});
  </script>

  <script src="js/script.js"></script>
</body>
</html>
